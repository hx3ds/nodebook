<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Box Diagram</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="contextMenu">
        <button id="menuDelete" onclick="app.deleteSelectedElement()">Delete</button>
        <button id="menuTag" onclick="app.showTagMenu(event)">Tag</button>
        <div id="tagMenu" style="display: none;">
            <button onclick="app.setBoxTag(null); event.stopPropagation();">Remove Tag</button>
            <div id="tagColors"></div>
        </div>
        <button id="menuArrowColor" onclick="app.showArrowColorMenu(event)">Color</button>
        <div id="arrowColorMenu" style="display: none;">
            <button onclick="app.setArrowColor(null); event.stopPropagation();">Default</button>
            <div id="arrowColors"></div>
        </div>
        <button id="menuExportJSON" onclick="app.exportCanvasJSON()">Export Canvas (JSON)</button>
        <button id="menuExportPNG" onclick="app.exportCanvasPNG()">Export Canvas (PNG)</button>
        <button id="menuImport" onclick="document.getElementById('importFile').click()">Import Canvas (JSON)</button>
    </div>
    <input id="importFile" type="file" accept="application/json,.json" style="display:none" />
    
    <div id="tagTooltip" style="position: fixed; display: none; background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; pointer-events: none; z-index: 3000;"></div>
    
    <div id="exportModal" style="display: none;">
        <div id="exportModalOverlay"></div>
        <div id="exportModalContent">
            <div id="exportModalHeader">
                <h3 id="exportModalTitle">Export File</h3>
            </div>
            <div id="exportModalBody">
                <label for="exportFileName">Filename:</label>
                <input type="text" id="exportFileName" placeholder="Enter filename">
                <label for="exportFileDirectory">Directory:</label>
                <div id="exportDirectoryContainer">
                    <input type="text" id="exportFileDirectory" placeholder="No directory selected" readonly>
                    <button id="exportSelectDirectory">Select Directory</button>
                </div>
            </div>
            <div id="exportModalFooter">
                <button id="exportModalCancel">Cancel</button>
                <button id="exportModalConfirm">Export</button>
            </div>
        </div>
    </div>
    
    <textarea id="textInput"></textarea>
    
    <canvas id="canvas"></canvas>
    
    <script>
        const app = {
            canvas: null,
            ctx: null,
            boxes: [],
            arrows: [],
            selectedBox: null,
            selectedArrow: null,
            connectingFrom: null,
            connectingTo: null,
            editingBox: null,
            dragging: false,
            tagNames: {
                '#ef4444': 'Red',
                '#f59e0b': 'Orange',
                '#10b981': 'Green',
                '#3b82f6': 'Blue',
                '#8b5cf6': 'Purple',
                '#ec4899': 'Pink',
                '#6366f1': 'Indigo',
                '#06b6d4': 'Cyan'
            },
            hoveredTagBox: null,
            tooltipTimeout: null,
            middleDragging: false,
            panningCanvas: false,
            resizingBox: null,
            resizeHandle: null,
            dragOffset: { x: 0, y: 0 },
            canvasOffset: { x: 0, y: 0 },
            lastMousePos: { x: 0, y: 0 },
            lastPanPos: { x: 0, y: 0 },
            dpr: 1,
            pendingExportType: null,
            selectedDirectoryHandle: null,
            
            init() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('mouseleave', () => {
                    this.panningCanvas = false;
                    this.middleDragging = false;
                    this.dragging = false;
                    this.connectingFrom = null;
                    this.connectingTo = null;
                    this.hoveredTagBox = null;
                    this.hideTagTooltip();
                    if (this.tooltipTimeout) {
                        clearTimeout(this.tooltipTimeout);
                        this.tooltipTimeout = null;
                    }
                });
                this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                }, { passive: false });
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.handleRightClick(e);
                });
                // drag & drop import
                this.canvas.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });
                this.canvas.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]) {
                        const file = e.dataTransfer.files[0];
                        this.importFromFile(file);
                    }
                });
                
                document.addEventListener('click', (e) => {
                    const menu = document.getElementById('contextMenu');
                    const tagMenu = document.getElementById('tagMenu');
                    const arrowColorMenu = document.getElementById('arrowColorMenu');
                    if (menu && !menu.contains(e.target) && (!tagMenu || !tagMenu.contains(e.target)) && (!arrowColorMenu || !arrowColorMenu.contains(e.target))) {
                        this.hideContextMenu();
                    }
                });
                
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                
                const textInput = document.getElementById('textInput');
                const importFile = document.getElementById('importFile');
                textInput.addEventListener('input', () => {
                    if (this.editingBox) {
                        this.editingBox.text = textInput.value;
                        this.render();
                    }
                });
                
                textInput.addEventListener('blur', () => {
                    this.finishEditing();
                });
                
                textInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.finishEditing();
                        e.preventDefault();
                    }
                    e.stopPropagation();
                });
                importFile.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (file) {
                        this.importFromFile(file);
                        e.target.value = '';
                    }
                });
                
                const exportModal = document.getElementById('exportModal');
                const exportModalCancel = document.getElementById('exportModalCancel');
                const exportModalConfirm = document.getElementById('exportModalConfirm');
                const exportFileName = document.getElementById('exportFileName');
                const exportModalOverlay = document.getElementById('exportModalOverlay');
                const exportSelectDirectory = document.getElementById('exportSelectDirectory');
                
                exportModalCancel.addEventListener('click', () => this.hideExportModal());
                exportModalConfirm.addEventListener('click', () => this.confirmExport());
                exportModalOverlay.addEventListener('click', () => this.hideExportModal());
                exportSelectDirectory.addEventListener('click', () => this.selectDirectory());
                
                exportFileName.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.confirmExport();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        this.hideExportModal();
                    }
                });
                
                this.loadTagNames();
                this.loadState();
                this.render();
            },
            
            async selectDirectory() {
                if (!window.showDirectoryPicker) {
                    alert('Directory selection is not supported in your browser. Please use a modern browser like Chrome, Edge, or Opera.');
                    return;
                }
                
                try {
                    const handle = await window.showDirectoryPicker();
                    this.selectedDirectoryHandle = handle;
                    const exportFileDirectory = document.getElementById('exportFileDirectory');
                    exportFileDirectory.value = handle.name;
                } catch (e) {
                    if (e.name !== 'AbortError') {
                        console.error('Error selecting directory:', e);
                    }
                }
            },
            
            showExportModal(type, defaultExtension) {
                this.pendingExportType = type;
                this.selectedDirectoryHandle = null;
                const exportModal = document.getElementById('exportModal');
                const exportFileName = document.getElementById('exportFileName');
                const exportFileDirectory = document.getElementById('exportFileDirectory');
                const exportModalTitle = document.getElementById('exportModalTitle');
                const exportSelectDirectory = document.getElementById('exportSelectDirectory');
                
                const ts = new Date().toISOString().replace(/[:.]/g, '-');
                const defaultName = `canvas-${ts}`;
                
                exportModalTitle.textContent = type === 'json' ? 'Export Canvas (JSON)' : 'Export Canvas (PNG)';
                exportFileName.value = defaultName;
                exportFileDirectory.value = '';
                
                if (!window.showDirectoryPicker) {
                    exportSelectDirectory.style.display = 'none';
                } else {
                    exportSelectDirectory.style.display = 'block';
                }
                
                exportModal.style.display = 'flex';
                
                setTimeout(() => {
                    exportFileName.focus();
                    exportFileName.select();
                }, 100);
            },
            
            hideExportModal() {
                const exportModal = document.getElementById('exportModal');
                exportModal.style.display = 'none';
                this.pendingExportType = null;
                this.selectedDirectoryHandle = null;
                const exportFileDirectory = document.getElementById('exportFileDirectory');
                if (exportFileDirectory) {
                    exportFileDirectory.value = '';
                }
            },
            
            async confirmExport() {
                if (!this.pendingExportType) return;
                
                const exportFileName = document.getElementById('exportFileName');
                const fileName = exportFileName.value.trim();
                
                if (!fileName) {
                    exportFileName.focus();
                    return;
                }
                
                const extension = this.pendingExportType === 'json' ? '.json' : '.png';
                const finalName = fileName.replace(new RegExp(`\\.${extension.slice(1)}$`, 'i'), '') + extension;
                
                if (this.selectedDirectoryHandle) {
                    if (this.pendingExportType === 'json') {
                        await this.performJSONExportToDirectory(finalName);
                    } else {
                        await this.performPNGExportToDirectory(finalName);
                    }
                } else {
                    if (this.pendingExportType === 'json') {
                        this.performJSONExport(finalName);
                    } else {
                        this.performPNGExport(finalName);
                    }
                }
                
                this.hideExportModal();
            },
            
            async performJSONExportToDirectory(fileName) {
                try {
                    const state = this.serializeState();
                    const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
                    const fileHandle = await this.selectedDirectoryHandle.getFileHandle(fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                } catch (e) {
                    console.error('Error writing file to directory:', e);
                    alert('Failed to save file to selected directory. Falling back to download.');
                    this.performJSONExport(fileName);
                }
            },
            
            performJSONExport(fileName) {
                const state = this.serializeState();
                const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            },
            
            exportCanvasJSON() {
                this.showExportModal('json', '.json');
            },
            
            async performPNGExportToDirectory(fileName) {
                try {
                    const off = document.createElement('canvas');
                    off.width = this.canvas.width;
                    off.height = this.canvas.height;
                    const octx = off.getContext('2d');
                    octx.fillStyle = '#ffffff';
                    octx.fillRect(0, 0, off.width, off.height);
                    octx.drawImage(this.canvas, 0, 0);
                    
                    const blob = await new Promise((resolve, reject) => {
                        off.toBlob((blob) => {
                            if (blob) resolve(blob);
                            else reject(new Error('Failed to create blob'));
                        }, 'image/png');
                    });
                    
                    const fileHandle = await this.selectedDirectoryHandle.getFileHandle(fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                } catch (e) {
                    console.error('Error writing file to directory:', e);
                    alert('Failed to save file to selected directory. Falling back to download.');
                    this.performPNGExport(fileName);
                }
            },
            
            performPNGExport(fileName) {
                const off = document.createElement('canvas');
                off.width = this.canvas.width;
                off.height = this.canvas.height;
                const octx = off.getContext('2d');
                octx.fillStyle = '#ffffff';
                octx.fillRect(0, 0, off.width, off.height);
                octx.drawImage(this.canvas, 0, 0);
                off.toBlob((blob) => {
                    if (!blob) return;
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 'image/png');
            },
            
            exportCanvasPNG() {
                this.showExportModal('png', '.png');
            },
            
            importFromFile(file) {
                const reader = new FileReader();
                reader.onload = () => {
                    try {
                        const data = JSON.parse(reader.result);
                        this.loadFromState(data);
                        this.saveState();
                        this.render();
                    } catch (e) {
                        console.error('Failed to import file:', e);
                    }
                };
                reader.onerror = () => {
                    console.error('Failed to read file');
                };
                reader.readAsText(file);
            },
            
            serializeState() {
                return {
                    boxes: this.boxes.map(box => ({
                        id: box.id,
                        x: box.x,
                        y: box.y,
                        width: box.width,
                        height: box.height,
                        defaultWidth: box.defaultWidth,
                        defaultHeight: box.defaultHeight,
                        text: box.text || '',
                        expanded: !!box.expanded,
                        tag: box.tag || null
                    })),
                    arrows: this.arrows.map(a => ({
                        sourceId: a.source.id,
                        targetId: a.target.id,
                        color: a.color || null
                    }))
                };
            },
            
            loadFromState(state) {
                if (!state) {
                    return;
                }
                if (!Array.isArray(state.boxes)) {
                    state.boxes = [];
                }
                if (!Array.isArray(state.arrows)) {
                    state.arrows = [];
                }
                const idToBox = new Map();
                this.boxes = state.boxes.map(b => {
                    let tag = b.tag || null;
                    if (!tag && b.tagColor) {
                        tag = { color: b.tagColor, name: '' };
                    }
                    const box = {
                        id: b.id || (Date.now() + Math.random()),
                        x: b.x || 0,
                        y: b.y || 0,
                        width: b.width || 150,
                        height: b.height || 80,
                        defaultWidth: b.defaultWidth ?? b.width ?? 150,
                        defaultHeight: b.defaultHeight ?? b.height ?? 80,
                        text: b.text || '',
                        expanded: !!b.expanded,
                        tag: tag
                    };
                    idToBox.set(box.id, box);
                    return box;
                });
                this.arrows = state.arrows
                    .map(a => {
                        if (!a || !a.sourceId || !a.targetId) {
                            return null;
                        }
                        const source = idToBox.get(a.sourceId);
                        const target = idToBox.get(a.targetId);
                        if (source && target && source !== target) {
                            return { 
                                source, 
                                target, 
                                color: a.color || null 
                            };
                        }
                        return null;
                    })
                    .filter(Boolean);
                this.selectedBox = null;
                this.selectedArrow = null;
                this.connectingFrom = null;
                this.connectingTo = null;
            },
            
            resizeCanvas() {
                this.dpr = window.devicePixelRatio || 1;
                const width = window.innerWidth;
                const height = window.innerHeight;
                this.canvas.width = width * this.dpr;
                this.canvas.height = height * this.dpr;
                this.canvas.style.width = width + 'px';
                this.canvas.style.height = height + 'px';
                this.ctx.scale(this.dpr, this.dpr);
                this.render();
            },
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: (e.clientX - rect.left) - this.canvasOffset.x,
                    y: (e.clientY - rect.top) - this.canvasOffset.y
                };
            },
            
            createBox(x, y) {
                const box = {
                    id: Date.now() + Math.random(),
                    x: x - 75,
                    y: y - 40,
                    width: 150,
                    height: 80,
                    defaultWidth: 150,
                    defaultHeight: 80,
                    text: '',
                    selected: false,
                    expanded: false,
                    tag: null
                };
                this.boxes.push(box);
                this.saveState();
                this.render();
            },
            
            findBoxAt(x, y) {
                for (let i = this.boxes.length - 1; i >= 0; i--) {
                    const box = this.boxes[i];
                    if (x >= box.x && x <= box.x + box.width &&
                        y >= box.y && y <= box.y + box.height) {
                        return box;
                    }
                }
                return null;
            },
            
            isExpandButtonAt(x, y, box) {
                if (!this.shouldShowExpandButton(box)) {
                    return false;
                }
                const buttonRadius = 10;
                const buttonX = box.x + box.width - buttonRadius - 8;
                const buttonY = box.y + buttonRadius + 8;
                const distance = Math.sqrt((x - buttonX) ** 2 + (y - buttonY) ** 2);
                return distance <= buttonRadius;
            },
            
            shouldShowExpandButton(box) {
                if (!box.text || box.text.trim() === '') {
                    return false;
                }
                const padding = 20;
                const maxWidth = box.defaultWidth - padding * 2;
                this.ctx.font = '15px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                const lines = this.wrapText(box.text, maxWidth);
                const lineHeight = 20;
                const maxLines = Math.floor((box.defaultHeight - padding * 2) / lineHeight);
                return lines.length > maxLines || lines.length > 1;
            },
            
            toggleBoxExpansion(box) {
                if (box.expanded) {
                    box.width = box.defaultWidth;
                    box.height = box.defaultHeight;
                    box.expanded = false;
                } else {
                    const measurements = this.measureText(box.text);
                    box.height = Math.max(box.defaultHeight, measurements.height + 40);
                    box.expanded = true;
                }
                this.saveState();
                this.render();
            },
            
            getResizeHandle(x, y, box) {
                const handleSize = 8;
                const tolerance = 4;
                
                const right = box.x + box.width;
                const bottom = box.y + box.height;
                
                if (Math.abs(x - right) <= handleSize + tolerance && 
                    Math.abs(y - bottom) <= handleSize + tolerance) {
                    return 'se';
                }
                
                if (Math.abs(x - right) <= handleSize + tolerance && 
                    y >= box.y + tolerance && y <= bottom - tolerance) {
                    return 'e';
                }
                
                if (Math.abs(y - bottom) <= handleSize + tolerance && 
                    x >= box.x + tolerance && x <= right - tolerance) {
                    return 's';
                }
                
                return null;
            },
            
            measureText(text) {
                this.ctx.font = '15px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                const maxWidth = 600;
                const lineHeight = 20;
                
                const lines = this.wrapText(text, maxWidth);
                const width = Math.max(...lines.map(line => this.ctx.measureText(line).width), 100);
                const height = lines.length * lineHeight;
                
                return { width, height, lines };
            },
            
            wrapText(text, maxWidth) {
                if (!text || text.trim() === '') {
                    return [''];
                }
                
                const lines = [];
                const paragraphs = text.split('\n');
                
                for (const paragraph of paragraphs) {
                    if (paragraph.trim() === '') {
                        lines.push('');
                        continue;
                    }
                    
                    const words = paragraph.split(' ');
                    let currentLine = '';
                    
                    for (const word of words) {
                        const testLine = currentLine ? currentLine + ' ' + word : word;
                        const metrics = this.ctx.measureText(testLine);
                        
                        if (metrics.width > maxWidth) {
                            if (currentLine) {
                                lines.push(currentLine);
                                currentLine = word;
                            } else {
                                let charLine = '';
                                for (const char of word) {
                                    const testChar = charLine + char;
                                    const charMetrics = this.ctx.measureText(testChar);
                                    if (charMetrics.width > maxWidth && charLine) {
                                        lines.push(charLine);
                                        charLine = char;
                                    } else {
                                        charLine = testChar;
                                    }
                                }
                                if (charLine) {
                                    currentLine = charLine;
                                }
                            }
                        } else {
                            currentLine = testLine;
                        }
                    }
                    
                    if (currentLine) {
                        lines.push(currentLine);
                    }
                }
                
                return lines.length > 0 ? lines : [''];
            },
            
            findArrowAt(x, y) {
                for (let i = this.arrows.length - 1; i >= 0; i--) {
                    const arrow = this.arrows[i];
                    const path = this.calculateArrowPath(arrow);
                    if (this.isPointNearPath(x, y, path)) {
                        return arrow;
                    }
                }
                return null;
            },
            
            calculateArrowPath(arrow) {
                const source = arrow.source;
                const target = arrow.target;
                
                const sourceCenter = {
                    x: source.x + source.width / 2,
                    y: source.y + source.height / 2
                };
                const targetCenter = {
                    x: target.x + target.width / 2,
                    y: target.y + target.height / 2
                };
                
                const dx = targetCenter.x - sourceCenter.x;
                const dy = targetCenter.y - sourceCenter.y;
                
                const sourceEdge = this.getBoxEdgePoint(source, dx, dy);
                const targetEdge = this.getBoxEdgePoint(target, -dx, -dy);
                
                const sourceSide = this.getBoxSide(source, dx, dy);
                const targetSide = this.getBoxSide(target, -dx, -dy);
                
                const distance = Math.sqrt(
                    (targetEdge.x - sourceEdge.x) ** 2 + 
                    (targetEdge.y - sourceEdge.y) ** 2
                );
                
                const handleDistance = Math.min(distance * 0.45, 100);
                
                let cp1x, cp1y, cp2x, cp2y;
                
                switch(sourceSide) {
                    case 'right':
                        cp1x = sourceEdge.x + handleDistance;
                        cp1y = sourceEdge.y;
                        break;
                    case 'left':
                        cp1x = sourceEdge.x - handleDistance;
                        cp1y = sourceEdge.y;
                        break;
                    case 'bottom':
                        cp1x = sourceEdge.x;
                        cp1y = sourceEdge.y + handleDistance;
                        break;
                    case 'top':
                        cp1x = sourceEdge.x;
                        cp1y = sourceEdge.y - handleDistance;
                        break;
                }
                
                switch(targetSide) {
                    case 'right':
                        cp2x = targetEdge.x + handleDistance;
                        cp2y = targetEdge.y;
                        break;
                    case 'left':
                        cp2x = targetEdge.x - handleDistance;
                        cp2y = targetEdge.y;
                        break;
                    case 'bottom':
                        cp2x = targetEdge.x;
                        cp2y = targetEdge.y + handleDistance;
                        break;
                    case 'top':
                        cp2x = targetEdge.x;
                        cp2y = targetEdge.y - handleDistance;
                        break;
                }
                
                return {
                    x1: sourceEdge.x,
                    y1: sourceEdge.y,
                    cp1x: cp1x,
                    cp1y: cp1y,
                    cp2x: cp2x,
                    cp2y: cp2y,
                    x2: targetEdge.x,
                    y2: targetEdge.y
                };
            },
            
            getBoxSide(box, dx, dy) {
                const centerX = box.x + box.width / 2;
                const centerY = box.y + box.height / 2;
                
                const angle = Math.atan2(dy, dx);
                const halfWidth = box.width / 2;
                const halfHeight = box.height / 2;
                
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                if (Math.abs(cos) > Math.abs(sin * halfWidth / halfHeight)) {
                    return cos > 0 ? 'right' : 'left';
                } else {
                    return sin > 0 ? 'bottom' : 'top';
                }
            },
            
            getBoxEdgePoint(box, dx, dy) {
                const centerX = box.x + box.width / 2;
                const centerY = box.y + box.height / 2;
                
                const angle = Math.atan2(dy, dx);
                
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                const halfWidth = box.width / 2;
                const halfHeight = box.height / 2;
                
                let edgeX, edgeY;
                
                if (Math.abs(cos) > Math.abs(sin * halfWidth / halfHeight)) {
                    edgeX = centerX + Math.sign(cos) * halfWidth;
                    edgeY = centerY + Math.sign(cos) * halfWidth * Math.tan(angle);
                } else {
                    edgeX = centerX + Math.sign(sin) * halfHeight / Math.tan(angle);
                    edgeY = centerY + Math.sign(sin) * halfHeight;
                }
                
                return { x: edgeX, y: edgeY };
            },
            
            isPointNearPath(x, y, path) {
                const segments = 30;
                let minDist = Infinity;
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const mt = 1 - t;
                    const curveX = mt * mt * mt * path.x1 + 
                                   3 * mt * mt * t * path.cp1x + 
                                   3 * mt * t * t * path.cp2x + 
                                   t * t * t * path.x2;
                    const curveY = mt * mt * mt * path.y1 + 
                                   3 * mt * mt * t * path.cp1y + 
                                   3 * mt * t * t * path.cp2y + 
                                   t * t * t * path.y2;
                    const dist = Math.sqrt((x - curveX) ** 2 + (y - curveY) ** 2);
                    minDist = Math.min(minDist, dist);
                }
                
                return minDist < 10;
            },
            
            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            },
            
            connectBoxes(source, target) {
                if (source === target) return;
                
                for (const arrow of this.arrows) {
                    if (arrow.source === source && arrow.target === target) {
                        return;
                    }
                }
                
                this.arrows.push({ source, target, color: null });
                this.saveState();
                this.render();
            },
            
            startEditing(box, clickX, clickY) {
                this.editingBox = box;
                const textInput = document.getElementById('textInput');
                textInput.value = box.text;
                
                const rect = this.canvas.getBoundingClientRect();
                const boxScreenX = box.x + this.canvasOffset.x + rect.left;
                const boxScreenY = box.y + this.canvasOffset.y + rect.top;
                
                textInput.style.left = boxScreenX + 'px';
                textInput.style.top = boxScreenY + 'px';
                textInput.style.width = box.width + 'px';
                textInput.style.height = box.height + 'px';
                textInput.style.display = 'block';
                textInput.focus();
                
                if (clickX !== undefined && clickY !== undefined) {
                    setTimeout(() => {
                        const relativeX = clickX - box.x;
                        const relativeY = clickY - box.y;
                        
                        const charIndex = this.getCharIndexFromPoint(textInput, relativeX, relativeY);
                        textInput.setSelectionRange(charIndex, charIndex);
                    }, 0);
                } else {
                    textInput.select();
                }
                
                this.render();
            },
            
            getCharIndexFromPoint(textInput, x, y) {
                const text = textInput.value;
                let bestIndex = text.length;
                return bestIndex;
            },
            
            finishEditing() {
                if (this.editingBox) {
                    const textInput = document.getElementById('textInput');
                    this.editingBox.text = textInput.value;
                    this.editingBox = null;
                    textInput.style.display = 'none';
                    this.saveState();
                    this.render();
                }
            },
            
            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                const box = this.findBoxAt(pos.x, pos.y);
                const arrow = this.findArrowAt(pos.x, pos.y);
                
                if (this.editingBox && this.editingBox !== box) {
                    this.finishEditing();
                }
                
                if (box && this.isExpandButtonAt(pos.x, pos.y, box)) {
                    this.toggleBoxExpansion(box);
                    return;
                }
                
                if (e.button === 1) {
                    if (box) {
                        this.selectedBox = box;
                        this.selectedArrow = null;
                        // bring box to front
                        const idx = this.boxes.indexOf(box);
                        if (idx > -1) {
                            this.boxes.splice(idx, 1);
                            this.boxes.push(box);
                        }
                        this.middleDragging = true;
                        this.dragOffset = {
                            x: pos.x - box.x,
                            y: pos.y - box.y
                        };
                        this.canvas.style.cursor = 'move';
                    } else {
                        this.panningCanvas = true;
                        this.lastPanPos = { x: e.clientX, y: e.clientY };
                        this.canvas.style.cursor = 'grab';
                    }
                    this.render();
                    return;
                }
                
                if (e.button === 2) {
                    return;
                }
                
                if (box) {
                    if (this.editingBox === box) {
                        return;
                    }
                    
                    const resizeHandle = this.getResizeHandle(pos.x, pos.y, box);
                    if (resizeHandle) {
                        this.resizingBox = box;
                        this.resizeHandle = resizeHandle;
                        this.selectedBox = box;
                        this.selectedArrow = null;
                        // bring box to front
                        const idx = this.boxes.indexOf(box);
                        if (idx > -1) {
                            this.boxes.splice(idx, 1);
                            this.boxes.push(box);
                        }
                        return;
                    }
                    
                    this.selectedBox = box;
                    this.selectedArrow = null;
                    // bring box to front
                    const idx2 = this.boxes.indexOf(box);
                    if (idx2 > -1) {
                        this.boxes.splice(idx2, 1);
                        this.boxes.push(box);
                    }
                    this.connectingFrom = box;
                    this.dragging = true;
                    this.dragOffset = {
                        x: pos.x - box.x,
                        y: pos.y - box.y
                    };
                    this.canvas.style.cursor = 'crosshair';
                } else if (arrow) {
                    this.selectedBox = null;
                    this.selectedArrow = arrow;
                    // bring arrow to front
                    const aidx = this.arrows.indexOf(arrow);
                    if (aidx > -1) {
                        this.arrows.splice(aidx, 1);
                        this.arrows.push(arrow);
                    }
                } else {
                    this.selectedBox = null;
                    this.selectedArrow = null;
                    this.connectingFrom = null;
                }
                
                this.render();
            },
            
            handleMouseMove(e) {
                if (this.panningCanvas) {
                    const dx = e.clientX - this.lastPanPos.x;
                    const dy = e.clientY - this.lastPanPos.y;
                    this.canvasOffset.x += dx;
                    this.canvasOffset.y += dy;
                    this.lastPanPos = { x: e.clientX, y: e.clientY };
                    this.canvas.style.cursor = 'grabbing';
                    this.render();
                    return;
                }
                
                const pos = this.getMousePos(e);
                this.lastMousePos = pos;
                
                const dotRadius = 6;
                const tolerance = 8;
                let foundHover = false;
                
                if (!this.resizingBox && !this.dragging && !this.middleDragging && !this.panningCanvas) {
                    for (const box of this.boxes) {
                        if (box.tag && box.tag.color) {
                            const dotX = box.x + dotRadius + 8;
                            const dotY = box.y + dotRadius + 8;
                            const distance = Math.sqrt((pos.x - dotX) ** 2 + (pos.y - dotY) ** 2);
                            
                            if (distance <= dotRadius + tolerance) {
                                if (this.hoveredTagBox !== box) {
                                    this.hoveredTagBox = box;
                                    if (this.tooltipTimeout) {
                                        clearTimeout(this.tooltipTimeout);
                                    }
                                    this.tooltipTimeout = setTimeout(() => {
                                        this.showTagTooltip(e.clientX, e.clientY, box);
                                    }, 300);
                                } else {
                                    const tooltip = document.getElementById('tagTooltip');
                                    if (tooltip && tooltip.style.display !== 'none') {
                                        tooltip.style.left = (e.clientX + 10) + 'px';
                                        tooltip.style.top = (e.clientY + 10) + 'px';
                                    }
                                }
                                foundHover = true;
                                break;
                            }
                        }
                    }
                    
                    if (!foundHover && this.hoveredTagBox) {
                        this.hoveredTagBox = null;
                        this.hideTagTooltip();
                        if (this.tooltipTimeout) {
                            clearTimeout(this.tooltipTimeout);
                            this.tooltipTimeout = null;
                        }
                    }
                }
                
                if (this.resizingBox) {
                    const minSize = 50;
                    if (this.resizeHandle === 'se') {
                        this.resizingBox.width = Math.max(minSize, pos.x - this.resizingBox.x);
                        this.resizingBox.height = Math.max(minSize, pos.y - this.resizingBox.y);
                    } else if (this.resizeHandle === 'e') {
                        this.resizingBox.width = Math.max(minSize, pos.x - this.resizingBox.x);
                    } else if (this.resizeHandle === 's') {
                        this.resizingBox.height = Math.max(minSize, pos.y - this.resizingBox.y);
                    }
                    this.render();
                    return;
                }
                
                if (this.middleDragging && this.selectedBox) {
                    this.selectedBox.x = pos.x - this.dragOffset.x;
                    this.selectedBox.y = pos.y - this.dragOffset.y;
                    this.render();
                    return;
                }
                
                if (this.dragging && this.connectingFrom) {
                    const targetBox = this.findBoxAt(pos.x, pos.y);
                    if (targetBox && targetBox !== this.connectingFrom) {
                        this.connectingTo = targetBox;
                    } else {
                        this.connectingTo = null;
                    }
                    this.render();
                } else {
                    const box = this.findBoxAt(pos.x, pos.y);
                    if (box) {
                        if (this.isExpandButtonAt(pos.x, pos.y, box)) {
                            this.canvas.style.cursor = 'pointer';
                        } else {
                            const resizeHandle = this.getResizeHandle(pos.x, pos.y, box);
                            if (resizeHandle === 'se') {
                                this.canvas.style.cursor = 'nwse-resize';
                            } else if (resizeHandle === 'e') {
                                this.canvas.style.cursor = 'ew-resize';
                            } else if (resizeHandle === 's') {
                                this.canvas.style.cursor = 'ns-resize';
                            } else {
                                this.canvas.style.cursor = 'pointer';
                            }
                        }
                    } else {
                        this.canvas.style.cursor = 'default';
                    }
                }
            },
            
            handleMouseUp(e) {
                if (this.resizingBox) {
                    this.resizingBox.defaultWidth = this.resizingBox.width;
                    this.resizingBox.defaultHeight = this.resizingBox.height;
                    this.resizingBox = null;
                    this.resizeHandle = null;
                    this.canvas.style.cursor = 'default';
                    this.saveState();
                    return;
                }
                
                if (e.button === 1) {
                    if (this.panningCanvas) {
                        this.panningCanvas = false;
                        this.canvas.style.cursor = 'default';
                        return;
                    }
                    if (this.middleDragging) {
                        this.middleDragging = false;
                        this.canvas.style.cursor = 'default';
                        this.saveState();
                        return;
                    }
                }
                
                if (this.dragging && this.connectingFrom) {
                    const pos = this.getMousePos(e);
                    const targetBox = this.findBoxAt(pos.x, pos.y);
                    
                    if (targetBox && targetBox !== this.connectingFrom) {
                        this.connectBoxes(this.connectingFrom, targetBox);
                    }
                    
                    this.dragging = false;
                    this.connectingFrom = null;
                    this.connectingTo = null;
                    this.saveState();
                    this.render();
                }
            },
            
            handleDoubleClick(e) {
                const pos = this.getMousePos(e);
                const box = this.findBoxAt(pos.x, pos.y);
                
                if (box) {
                    if (this.isExpandButtonAt(pos.x, pos.y, box)) {
                        return;
                    }
                    this.startEditing(box, pos.x, pos.y);
                } else {
                    this.createBox(pos.x, pos.y);
                }
            },
            
            handleRightClick(e) {
                const pos = this.getMousePos(e);
                const box = this.findBoxAt(pos.x, pos.y);
                const arrow = this.findArrowAt(pos.x, pos.y);
                this.selectedBox = box || null;
                this.selectedArrow = arrow || null;
                if (box) {
                    const idx = this.boxes.indexOf(box);
                    if (idx > -1) {
                        this.boxes.splice(idx, 1);
                        this.boxes.push(box);
                    }
                }
                if (arrow) {
                    const aidx = this.arrows.indexOf(arrow);
                    if (aidx > -1) {
                        this.arrows.splice(aidx, 1);
                        this.arrows.push(arrow);
                    }
                }
                this.showContextMenu(e.clientX, e.clientY);
                this.render();
                e.preventDefault();
            },
            
            showContextMenu(x, y) {
                const menu = document.getElementById('contextMenu');
                const del = document.getElementById('menuDelete');
                const tagBtn = document.getElementById('menuTag');
                const tagMenu = document.getElementById('tagMenu');
                const arrowColorBtn = document.getElementById('menuArrowColor');
                const arrowColorMenu = document.getElementById('arrowColorMenu');
                const exportJSON = document.getElementById('menuExportJSON');
                const exportPNG = document.getElementById('menuExportPNG');
                const importBtn = document.getElementById('menuImport');
                
                const hasSelection = !!(this.selectedBox || this.selectedArrow);
                
                if (del) {
                    del.style.display = hasSelection ? 'block' : 'none';
                }
                
                if (tagBtn) {
                    tagBtn.style.display = this.selectedBox ? 'block' : 'none';
                }
                
                if (arrowColorBtn) {
                    arrowColorBtn.style.display = this.selectedArrow ? 'block' : 'none';
                }
                
                if (exportJSON) {
                    exportJSON.style.display = hasSelection ? 'none' : 'block';
                }
                
                if (exportPNG) {
                    exportPNG.style.display = hasSelection ? 'none' : 'block';
                }
                
                if (importBtn) {
                    importBtn.style.display = hasSelection ? 'none' : 'block';
                }
                
                if (tagMenu) {
                    tagMenu.style.display = 'none';
                }
                
                if (arrowColorMenu) {
                    arrowColorMenu.style.display = 'none';
                }
                
                menu.style.display = 'block';
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
            },
            
            showTagMenu(e) {
                if (e) {
                    e.stopPropagation();
                }
                const tagMenu = document.getElementById('tagMenu');
                const tagColors = document.getElementById('tagColors');
                if (!tagMenu || !tagColors) return;
                
                if (tagMenu.style.display === 'none' || !tagMenu.style.display) {
                    tagColors.innerHTML = '';
                    Object.keys(this.tagNames).forEach(color => {
                        const container = document.createElement('div');
                        container.style.display = 'flex';
                        container.style.alignItems = 'center';
                        container.style.gap = '8px';
                        container.style.padding = '2px 0';
                        
                        const btn = document.createElement('button');
                        btn.style.flex = '1';
                        btn.style.display = 'flex';
                        btn.style.alignItems = 'center';
                        btn.style.gap = '8px';
                        const currentTag = this.selectedBox && this.selectedBox.tag;
                        const isSelected = currentTag && currentTag.color === color;
                        const tagName = this.tagNames[color] || color;
                        
                        const dotSpan = document.createElement('span');
                        dotSpan.style.display = 'inline-block';
                        dotSpan.style.width = '12px';
                        dotSpan.style.height = '12px';
                        dotSpan.style.borderRadius = '50%';
                        dotSpan.style.background = color;
                        dotSpan.style.border = '1px solid rgba(0,0,0,0.1)';
                        
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = tagName;
                        nameSpan.style.flex = '1';
                        
                        if (isSelected) {
                            btn.style.fontWeight = 'bold';
                        }
                        btn.onclick = (ev) => {
                            ev.stopPropagation();
                            this.setBoxTag(color);
                        };
                        
                        btn.appendChild(dotSpan);
                        btn.appendChild(nameSpan);
                        container.appendChild(btn);
                        tagColors.appendChild(container);
                    });
                    tagMenu.style.display = 'block';
                } else {
                    tagMenu.style.display = 'none';
                }
            },
            
            setBoxTag(color) {
                if (!this.selectedBox) return;
                if (color === null) {
                    this.selectedBox.tag = null;
                } else {
                    const existingTag = this.selectedBox.tag;
                    const defaultName = this.tagNames[color] || '';
                    this.selectedBox.tag = {
                        color: color,
                        name: existingTag && existingTag.color === color ? existingTag.name : defaultName
                    };
                }
                const tagMenu = document.getElementById('tagMenu');
                if (tagMenu) {
                    tagMenu.style.display = 'none';
                }
                this.saveState();
                this.render();
                this.hideContextMenu();
            },
            
            showArrowColorMenu(e) {
                if (e) {
                    e.stopPropagation();
                }
                const arrowColorMenu = document.getElementById('arrowColorMenu');
                const arrowColors = document.getElementById('arrowColors');
                if (!arrowColorMenu || !arrowColors) return;
                
                if (arrowColorMenu.style.display === 'none' || !arrowColorMenu.style.display) {
                    arrowColors.innerHTML = '';
                    Object.keys(this.tagNames).forEach(color => {
                        const container = document.createElement('div');
                        container.style.display = 'flex';
                        container.style.alignItems = 'center';
                        container.style.gap = '8px';
                        container.style.padding = '2px 0';
                        
                        const btn = document.createElement('button');
                        btn.style.flex = '1';
                        btn.style.display = 'flex';
                        btn.style.alignItems = 'center';
                        btn.style.gap = '8px';
                        const currentColor = this.selectedArrow && this.selectedArrow.color;
                        const isSelected = currentColor === color;
                        const colorName = this.tagNames[color] || color;
                        
                        const dotSpan = document.createElement('span');
                        dotSpan.style.display = 'inline-block';
                        dotSpan.style.width = '12px';
                        dotSpan.style.height = '12px';
                        dotSpan.style.borderRadius = '50%';
                        dotSpan.style.background = color;
                        dotSpan.style.border = '1px solid rgba(0,0,0,0.1)';
                        
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = colorName;
                        nameSpan.style.flex = '1';
                        
                        if (isSelected) {
                            btn.style.fontWeight = 'bold';
                        }
                        btn.onclick = (ev) => {
                            ev.stopPropagation();
                            this.setArrowColor(color);
                        };
                        
                        btn.appendChild(dotSpan);
                        btn.appendChild(nameSpan);
                        container.appendChild(btn);
                        arrowColors.appendChild(container);
                    });
                    arrowColorMenu.style.display = 'block';
                } else {
                    arrowColorMenu.style.display = 'none';
                }
            },
            
            setArrowColor(color) {
                if (!this.selectedArrow) return;
                this.selectedArrow.color = color;
                const arrowColorMenu = document.getElementById('arrowColorMenu');
                if (arrowColorMenu) {
                    arrowColorMenu.style.display = 'none';
                }
                this.saveState();
                this.render();
                this.hideContextMenu();
            },
            
            
            showTagTooltip(x, y, box) {
                if (!box.tag || !box.tag.color) return;
                const tooltip = document.getElementById('tagTooltip');
                if (!tooltip) return;
                const tagName = box.tag.name || this.tagNames[box.tag.color] || box.tag.color;
                tooltip.textContent = tagName;
                if (tooltip.style.display === 'none') {
                    tooltip.style.display = 'block';
                }
                tooltip.style.left = (x + 10) + 'px';
                tooltip.style.top = (y + 10) + 'px';
            },
            
            hideTagTooltip() {
                const tooltip = document.getElementById('tagTooltip');
                if (tooltip) {
                    tooltip.style.display = 'none';
                }
            },
            
            saveTagNames() {
                localStorage.setItem('tagNames', JSON.stringify(this.tagNames));
            },
            
            loadTagNames() {
                const saved = localStorage.getItem('tagNames');
                if (saved) {
                    try {
                        const names = JSON.parse(saved);
                        this.tagNames = { ...this.tagNames, ...names };
                    } catch (e) {
                    }
                }
            },
            
            hideContextMenu() {
                const menu = document.getElementById('contextMenu');
                if (menu) {
                    menu.style.display = 'none';
                }
            },
            
            handleKeyDown(e) {
                if (this.editingBox) {
                    return;
                }
                
                const exportModal = document.getElementById('exportModal');
                if (exportModal && exportModal.style.display !== 'none') {
                    if (e.key === 'Escape') {
                        this.hideExportModal();
                    }
                    return;
                }
                
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (this.selectedBox) {
                        this.boxes = this.boxes.filter(b => b !== this.selectedBox);
                        this.arrows = this.arrows.filter(a => 
                            a.source !== this.selectedBox && a.target !== this.selectedBox
                        );
                        this.selectedBox = null;
                        this.saveState();
                        this.render();
                    }
                } else if (e.key === 'Escape') {
                    this.selectedBox = null;
                    this.selectedArrow = null;
                    this.canvas.style.cursor = 'default';
                    this.render();
                } else if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (this.selectedBox || this.selectedArrow) {
                        this.deleteSelectedElement();
                    }
                }
            },
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width / this.dpr, this.canvas.height / this.dpr);
                
                this.ctx.save();
                this.ctx.translate(this.canvasOffset.x, this.canvasOffset.y);
                
                this.arrows.forEach(arrow => {
                    this.drawArrow(arrow);
                });
                
                this.boxes.forEach(box => {
                    this.drawBox(box);
                });
                
                if (this.connectingFrom && this.dragging) {
                    if (this.connectingTo) {
                        const previewArrow = {
                            source: this.connectingFrom,
                            target: this.connectingTo
                        };
                        const path = this.calculateArrowPath(previewArrow);
                        
                        this.ctx.strokeStyle = '#4285f4';
                        this.ctx.lineWidth = 2.5;
                        this.ctx.lineCap = 'round';
                        this.ctx.lineJoin = 'round';
                        this.ctx.globalAlpha = 0.7;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.beginPath();
                        this.ctx.moveTo(path.x1, path.y1);
                        this.ctx.bezierCurveTo(path.cp1x, path.cp1y, path.cp2x, path.cp2y, path.x2, path.y2);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                        this.ctx.globalAlpha = 1.0;
                    } else {
                        const pos = this.lastMousePos;
                        const sourceEdge = this.getBoxEdgePoint(
                            this.connectingFrom,
                            pos.x - (this.connectingFrom.x + this.connectingFrom.width / 2),
                            pos.y - (this.connectingFrom.y + this.connectingFrom.height / 2)
                        );
                        
                        this.ctx.strokeStyle = '#9aa0a6';
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.lineWidth = 1.5;
                        this.ctx.lineCap = 'round';
                        this.ctx.globalAlpha = 0.5;
                        this.ctx.beginPath();
                        this.ctx.moveTo(sourceEdge.x, sourceEdge.y);
                        this.ctx.lineTo(pos.x, pos.y);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                        this.ctx.globalAlpha = 1.0;
                    }
                }
                
                this.ctx.restore();
            },
            
            drawBox(box) {
                const radius = 8;
                const x = box.x;
                const y = box.y;
                const w = box.width;
                const h = box.height;
                
                this.ctx.save();
                
                this.ctx.beginPath();
                this.ctx.moveTo(x + radius, y);
                this.ctx.lineTo(x + w - radius, y);
                this.ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
                this.ctx.lineTo(x + w, y + h - radius);
                this.ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
                this.ctx.lineTo(x + radius, y + h);
                this.ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
                this.ctx.lineTo(x, y + radius);
                this.ctx.quadraticCurveTo(x, y, x + radius, y);
                this.ctx.closePath();
                
                const isSelected = this.selectedBox === box;
                
                if (isSelected) {
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.08)';
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 2;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#4285f4';
                    this.ctx.lineWidth = 2;
                } else {
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.08)';
                    this.ctx.shadowBlur = 6;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 2;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#dadce0';
                    this.ctx.lineWidth = 1;
                }
                
                this.ctx.stroke();
                this.ctx.restore();
                
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.rect(x, y, w, h);
                this.ctx.clip();
                
                const isEditing = this.editingBox === box;
                
                if (isEditing) {
                    this.ctx.restore();
                    return;
                }
                
                this.ctx.font = '15px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                this.ctx.fillStyle = isSelected ? '#1a73e8' : '#3c4043';
                
                if (box.expanded) {
                    const padding = 20;
                    const maxWidth = box.width - padding * 2;
                    this.ctx.font = '15px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    const lines = this.wrapText(box.text, maxWidth);
                    const lineHeight = 20;
                    const startY = box.y + 30;
                    
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'top';
                    lines.forEach((line, i) => {
                        this.ctx.fillText(
                            line,
                            box.x + padding,
                            startY + i * lineHeight
                        );
                    });
                } else {
                    const padding = 20;
                    const maxWidth = box.width - padding * 2;
                    this.ctx.font = '15px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    const lines = this.wrapText(box.text, maxWidth);
                    const lineHeight = 20;
                    const maxLines = Math.floor((box.height - padding * 2) / lineHeight);
                    const visibleLines = lines.slice(0, maxLines);
                    const startY = box.y + padding;
                    
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'top';
                    visibleLines.forEach((line, i) => {
                        let displayLine = line;
                        if (i === maxLines - 1 && lines.length > maxLines) {
                            while (displayLine.length > 0 && this.ctx.measureText(displayLine + '...').width > maxWidth) {
                                displayLine = displayLine.slice(0, -1);
                            }
                            displayLine += '...';
                        }
                        this.ctx.fillText(
                            displayLine,
                            box.x + padding,
                            startY + i * lineHeight
                        );
                    });
                }
                
                this.ctx.restore();
                
                if (box.tag && box.tag.color) {
                    const dotRadius = 6;
                    const dotX = box.x + dotRadius + 8;
                    const dotY = box.y + dotRadius + 8;
                    
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.arc(dotX, dotY, dotRadius, 0, Math.PI * 2);
                    this.ctx.fillStyle = box.tag.color;
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 1.5;
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                }
                
                if (this.shouldShowExpandButton(box)) {
                    const buttonRadius = 10;
                    const buttonX = box.x + box.width - buttonRadius - 8;
                    const buttonY = box.y + buttonRadius + 8;
                    
                    this.ctx.globalAlpha = 0.4;
                    this.ctx.strokeStyle = '#5f6368';
                    this.ctx.lineWidth = 1.2;
                    this.ctx.lineCap = 'round';
                    
                    if (box.expanded) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(buttonX - 3, buttonY);
                        this.ctx.lineTo(buttonX + 3, buttonY);
                        this.ctx.stroke();
                    } else {
                        this.ctx.beginPath();
                        this.ctx.moveTo(buttonX - 3, buttonY);
                        this.ctx.lineTo(buttonX + 3, buttonY);
                        this.ctx.stroke();
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(buttonX, buttonY - 3);
                        this.ctx.lineTo(buttonX, buttonY + 3);
                        this.ctx.stroke();
                    }
                    
                    this.ctx.globalAlpha = 1.0;
                }
                
            },
            
            drawArrow(arrow) {
                const path = this.calculateArrowPath(arrow);
                const isSelected = this.selectedArrow === arrow;
                const arrowColor = arrow.color || (isSelected ? '#1a73e8' : '#5f6368');
                
                this.ctx.strokeStyle = arrowColor;
                this.ctx.lineWidth = isSelected ? 2.5 : 1.5;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(path.x1, path.y1);
                this.ctx.bezierCurveTo(path.cp1x, path.cp1y, path.cp2x, path.cp2y, path.x2, path.y2);
                this.ctx.stroke();
                
                const t = 0.98;
                const mt = 1 - t;
                const beforeEndX = mt * mt * mt * path.x1 + 
                                   3 * mt * mt * t * path.cp1x + 
                                   3 * mt * t * t * path.cp2x + 
                                   t * t * t * path.x2;
                const beforeEndY = mt * mt * mt * path.y1 + 
                                   3 * mt * mt * t * path.cp1y + 
                                   3 * mt * t * t * path.cp2y + 
                                   t * t * t * path.y2;
                
                const angle = Math.atan2(path.y2 - beforeEndY, path.x2 - beforeEndX);
                const arrowLength = 8;
                const arrowWidth = 0.35;
                
                this.ctx.fillStyle = arrowColor;
                this.ctx.strokeStyle = arrowColor;
                this.ctx.lineWidth = isSelected ? 2.5 : 1.5;
                this.ctx.beginPath();
                this.ctx.moveTo(path.x2, path.y2);
                this.ctx.lineTo(
                    path.x2 - arrowLength * Math.cos(angle - arrowWidth),
                    path.y2 - arrowLength * Math.sin(angle - arrowWidth)
                );
                this.ctx.lineTo(
                    path.x2 - arrowLength * Math.cos(angle + arrowWidth),
                    path.y2 - arrowLength * Math.sin(angle + arrowWidth)
                );
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
            },
            
            deleteSelectedElement() {
                if (this.selectedBox) {
                    this.arrows = this.arrows.filter(arrow => 
                        arrow.source !== this.selectedBox && arrow.target !== this.selectedBox
                    );
                    this.boxes = this.boxes.filter(box => box !== this.selectedBox);
                    this.selectedBox = null;
                } else if (this.selectedArrow) {
                    this.arrows = this.arrows.filter(arrow => arrow !== this.selectedArrow);
                    this.selectedArrow = null;
                }
                this.saveState();
                this.render();
                this.hideContextMenu();
            },
            
            saveState() {
                const state = {
                    boxes: this.boxes.map(box => ({
                        id: box.id,
                        x: box.x,
                        y: box.y,
                        width: box.width,
                        height: box.height,
                        defaultWidth: box.defaultWidth,
                        defaultHeight: box.defaultHeight,
                        text: box.text || '',
                        expanded: !!box.expanded,
                        tag: box.tag || null
                    })),
                    arrows: this.arrows.map(arrow => ({
                        sourceId: arrow.source.id,
                        targetId: arrow.target.id,
                        color: arrow.color || null
                    }))
                };
                try {
                    localStorage.setItem('diagramState', JSON.stringify(state));
                } catch (e) {
                    console.error('Failed to save state:', e);
                }
            },
            
            loadState() {
                const saved = localStorage.getItem('diagramState');
                if (!saved) return;
                
                try {
                    const state = JSON.parse(saved);
                    this.loadFromState(state);
                } catch (e) {
                    console.error('Failed to load state:', e);
                }
            }
        };
        
        window.addEventListener('load', () => app.init());
    </script>
</body>
</html>
